---
layout: post
title:  "0.0.1 Notes"
date:   2014-07-26 22:30:00
categories: natureza elm
---

<div id="natureza0d0d1"></div>
<script src="js/Natureza-build-0.0.1.js"></script>
<script>
	Elm.embed(Elm.Natureza0d0d1, document.getElementById('natureza0d0d1'));
</script>

So, my first bit of <code>Elm</code> is written! I'm starting to get a sense of how the language works, though I admit I still feel relatively challenged by it. The type system in <code>Elm</code> has some constraints that I'm finding hard to work with. I'm sure it is something that also belongs to Haskell, but, for example, having to implicitly convert <code>Int</code> into <code>Float</code> has been challenging. I'm sure it has its benefits, but it was a source of headaches for me. Once I took a more proactive approach to ensuring <code>Int</code>s were explicity <code>Int</code>s and <code>Float</code> were explicitly <code>Float</code>, the type checker was a little more cooperative with me.

In general, I've found that if, in <code>Elm</code>, explicitly declaring types helped avoid headaches with the type system in general. More often than not, without explicitly declaring types, I'd make wrong assumptions about the type of the data I was working with, and get really head-scratching type errors deep inside some other function. I think its a best practice worth following!

So what has been accomplished, so far? Not much. Right now, I have a working grid system, and it should be easy to build enitities that render easily within this system thanks to this function I built:

	-- Some constants used in the math
	mapLen : Int
	mapLen = 5
	iOffset : Int
	iOffset = div mapLen 2
	imgSize : Int
	imgSize = 100

	atPos : (Int, Int) -> (Float, Float)
	atPos (x, y) = (toFloat((x-iOffset)*imgSize), toFloat((iOffset- y)*imgSize))
				
Building this function was a little more annoying than I hoped it'd be. I was hoping, honestly, for something a little closer to this:

	atPos : (Int, Int) -> (Float, Float)
	atPost (x, y) = (toFloat (x*imgSize), toFloat(y*imgSize))
	
But <code>Elm</code> does things oddly, in terms of how it handles its graphics (as compared to some other graphics stuff I used, like <code>SFML</code>). <code>collage x y forms</code>, for example, builds a 4 quadrant grid where +x is right, -x is left, +y is up, and -y is down. This is different than what I've encountered before, where there are no negative coordinates, +x is right, and +y is down. I like this secondary system a lot more, not only because I'm more used to working with it, but because it makes more sense for a grid system (specifically, matricies, which are ordered this way). Maybe in a game where the character is centered, thinking of the world in terms relative to the character is useful (especially if you're dealing with angles), but I think I'd be inconvenienced by this anywhere else. Plus, HTML flow down-right, so mentally I'd consider the origin of the canvas to be the top-left tip of it.

So I needed to negate y, and offset both by <code>div mapLen 2</code>, which, if we paste	and image from its top-left corner (which makes most sense in the flow down-right system I'm using -- this 4 quadrant thing makes no sense to me) means (0,0) would be right where at the top-left.

With that set up, running around the array wasn't hard.

	drawMap : Array(Array Tile) -> [Form]
	drawMap tmap = let 
	    range = (toList (initialize mapLen (\n -> n)))
	    drawTile : Int -> Int -> Tile -> Form
	    drawTile x y t = move (atPos (x, y)) <| toForm <| image imgSize imgSize t.src
    
	    selectAndDrawTile : Int -> Int -> Form
	    selectAndDrawTile x y = drawTile x y <| getOrFail x <| getOrFail y tmap

	    drawRowOfTilesFromArray : Int -> [Form]
	    drawRowOfTilesFromArray x = map (selectAndDrawTile x) range
	  in
	   foldl (++) [] <| map drawRowOfTilesFromArray range
		 
Some nice functional style with let, the bottom line of code is essentially a flatten function, that calls a function that returns a list of the created Form objects in that row. The two iterative functions <code>drawRowOfTilesFromArray</code> and <code>selectAndDrawTile</code> map a function on a range to loop through the array. <code>drawTile</code> takes the indicies created by these maps, converts them into positions on the screen, and creates a Form for it.

First impressions were less happy than I thought they'd be. I loved using a functional style to build this, but the 4-coordinate nature of the <code>Canvas</code> threw me in for a loop and caused me confusion. Additionally, I spent forever debugging an issue caused by Elm's weird precedence rules. Apparently, <code>toFloat 1/2</code> yields 0.5, which was not expected. I expected the division to be integer division, yield zero, and then be converted to zero. After lots of searching, I found out you need to use the <code>div 1 2</code> syntax to integer divide. I guess that's fine. It's, frankly, really weird, and not exactly intuitive to me (could be my C++ background). The major problem is that toFloat apparently has the same precedence as division. I wouldn't even expect <code>toFloat 1/2</code> to compile (cause it'd turn into <code>toFloat 0.5</code> in the kind of operator precedence I'd expect, and that would be a type error).

It's fine, though! I'm not at all discouraged, just a little annoyed at the amount of time I had to spend debugging some basic issues. Maybe this stuff is natural to Haskell people? I think I'm getting past a lot of the basic trip ups in the language, so I should get productive soon.

Next time, I add a <code>foldp</code> and some time into it! Make more, tinier squares! Have it dynamically react to window size! Maybe just one of the <code>Signal</code> based deals...but something!

See the project in all its current glory [here]("https://github.com/MysteryMachine/mysterymachine.github.io/tree/natureza0n0n1/elm").

*Note: If you're an Elm guy and my struggles are all my fault, and you have a solution, please reach out! My struggles probably ARE all my fault.*